
#include <iostream>

/*
동적할당 : 메모리가 생성되는 시점을 원하는 시점에 생성될 수 있도록
정해줄 수 있는 기능이다.
힙 영역에 공간이 만들어진다.
동적할당된 메모리는 필요없을경우 반드시 제거를 해주어야 한다.
동적할당된 메모리를 제거하지 않을경우 메모리 릭이 남게 된다.
new 키워드를 이용해서 원하는 타입을 동적할당한다.
new 는 연산자이다. new int 를 하면 int의 크기인 4바이트만큼
힙 영역에 공간을 만들고 생성된 공간의 메모리 주소를 반환해준다.

delete 키워드를 이용해서 메모리를 제거할 수 있다.
delete 주소; 로 제거한다.

메모리 단편화
- 내부 단편화 : 어떤 프로그램이 1mbyte 메모리를 사용하는데 OS는 실제 이
프로그램이 동작될 때 4mbyte의 공간을 할당해주었다. 이때 3mbyte는 사용하지
않는 메모리이므로 단편화가 3mbyte만큼 발생한 것이다.
- 외부 단편화 : 메모리 할당과 해제가 반복될 때 실제 생성된 메모리들이 
연속된 메모리 공간에 차례대로 할당되는 것이 아니기 때문에 중간중간
할당된 메모리들 사이에 공간이 비어있을 수 있다. 실제 큰 공간이 아니라도
이런 비어있는 공간이 많을 경우 메모리의 비어있는 총 크기는 클 수 있다.
이때 큰 메모리 공간이 필요할 때 실제 메모리는 그만큼 비어있지만 연속된
메모리 공간이 없어서 할당이 불가능한 상태를 말한다.

메모리 단편화 해결법
1. 페이징 기법 : 

2. 세그멘테이션 기법 : 

3. 메모리 풀 기법 : 
*/

int main()
{
	/*
	포인터와 동적할당 활용 코딩습관
	1. 포인터 변수는 일단 nullptr로 초기화한다.
	2. 동적할당 하려면 일단 delete부터 해놓고 시작하자.
	단, 포인터 변수에 메모리가 있을 경우를 예외처리한다.
	delete 후에 포인터 변수를 재사용 할수도 있기 때문에 nullptr로
	초기화한다.
	*/
	int* Number = new int;

	*Number = 10920;

	if (Number)
	{
		delete Number;
		Number = nullptr;
	}

	/*
	포인터 변수가 제거된 공간의 메모리 주소를 가지고 있을 경우
	댕글링 포인터라고 한다.
	*/
	if (Number)
		*Number = 500;

	int* Array = new int[100];

	Array[2] = 400;

	delete[] Array;

	return 0;
}
